<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>âš¡ï¸ P2P File Drop V3 (å®‰å®šç‰ˆ)</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --bg-color: #f8f9fa;
            --card-bg: #ffffff;
            --border-color: #e9ecef;
            --info-color: #17a2b8;
        }
        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            min-height: 100vh;
        }
        .container {
            width: 100%;
            max-width: 900px;
        }
        h1 {
            color: var(--primary-color);
            text-align: center;
            margin-bottom: 30px;
        }
        .card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        /* æ¥ç¶šã‚»ã‚¯ã‚·ãƒ§ãƒ³ */
        .connection-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }
        #status {
            font-weight: 700;
            padding: 5px 10px;
            border-radius: 4px;
        }
        .status-ready { background-color: #d4edda; color: var(--success-color); }
        .status-connecting { background-color: #fff3cd; color: #856404; }
        .status-error, .status-disconnected { background-color: #f8d7da; color: var(--danger-color); }
        .status-success { background-color: #d1ecf1; color: var(--info-color); }

        /* å…¥åŠ›ã‚¨ãƒªã‚¢ */
        .input-group {
            display: flex;
            gap: 10px;
        }
        .input-group input[type="text"] {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .input-group button {
            padding: 10px 20px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            flex-grow: 1;
        }
        .input-group button:hover:not(:disabled) {
            background-color: #0056b3;
        }
        .input-group button:disabled {
            background-color: var(--secondary-color);
            cursor: not-allowed;
        }

        /* ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‰ãƒ­ãƒƒãƒ—ã‚¨ãƒªã‚¢ */
        #drop-area {
            border: 2px dashed var(--primary-color);
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            margin-top: 15px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #drop-area.drag-over {
            background-color: #e9f0ff;
        }

        /* ãƒ­ã‚°ãƒ»é€²æ—è¡¨ç¤º */
        .log-item {
            padding: 10px 0;
            border-bottom: 1px dotted var(--border-color);
        }
        .log-item:last-child {
            border-bottom: none;
        }
        .progress-bar-container {
            width: 100%;
            background-color: #f0f0f0;
            border-radius: 5px;
            margin-top: 5px;
        }
        .progress-bar {
            height: 15px;
            background-color: var(--success-color);
            border-radius: 5px;
            transition: width 0.1s ease-in-out;
            text-align: center;
            color: white;
            font-size: 0.8em;
        }
        .download-link {
            display: block;
            margin-top: 10px;
            color: var(--primary-color);
            text-decoration: none;
            font-weight: bold;
        }
        .download-link:hover {
            text-decoration: underline;
        }
        
        /* ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚° */
        #debug-log-card {
            background-color: #212529;
            color: #ffffff;
            font-family: monospace;
            font-size: 0.9em;
            overflow-x: auto;
            border-radius: 8px;
            padding: 10px;
        }
        .debug-entry {
            border-bottom: 1px solid #343a40;
            padding: 5px 0;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>âš¡ï¸ P2P File Drop V3 (å®‰å®šç‰ˆ)</h1>
        <p>â€» ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ãƒ¼ã‚¿ã¯ç«¯æœ«é–“ã§ç›´æ¥è»¢é€ã•ã‚Œã¾ã™ã€‚æ¥ç¶šã«ã¯PeerJSã®ç„¡æ–™ã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</p>

        <div class="card" id="connection-card">
            <h2>ğŸ”— æ¥ç¶šè¨­å®š</h2>
            <div class="connection-info">
                <p>ç¾åœ¨ã®çŠ¶æ…‹:</p> <div id="status" class="status-connecting">åˆæœŸåŒ–ä¸­...</div>
            </div>
            
            <p><strong>æœ€åˆã«æ¥ç¶šã™ã‚‹æ–¹ãŒãƒ›ã‚¹ãƒˆï¼ˆå¾…æ©Ÿï¼‰</strong>ã€ç›¸æ‰‹ãŒã‚²ã‚¹ãƒˆï¼ˆæ¥ç¶šï¼‰ã§ã™ã€‚ãƒ›ã‚¹ãƒˆãŒæº–å‚™ã§ãã‚‹ã¾ã§ã€ã‚²ã‚¹ãƒˆã¯è‡ªå‹•ã§å†è©¦è¡Œã—ã¾ã™ã€‚</p>
            <label for="shared-pin"><strong>å…±æœ‰ã‚³ãƒ¼ãƒ‰ (PIN):</strong> ãŠäºŒäººã§æ±ºã‚ãŸä»»æ„ã®ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›</label>
            <div class="input-group">
                <input type="text" id="shared-pin" placeholder="ä¾‹: 1234, secret" maxlength="15">
                <button onclick="startHost()" id="host-btn">ãƒ›ã‚¹ãƒˆã¨ã—ã¦å¾…æ©Ÿ</button>
                <button onclick="startGuest()" id="guest-btn">ã‚²ã‚¹ãƒˆã¨ã—ã¦æ¥ç¶š</button>
            </div>
        </div>

        <div class="card">
            <h2>ğŸ“¤ ãƒ•ã‚¡ã‚¤ãƒ«é€ä¿¡</h2>
            <div id="drop-area">
                <p>ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã“ã“ã«ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—</p>
                <p>ã¾ãŸã¯</p>
                <input type="file" id="file-input" multiple hidden>
                <button onclick="document.getElementById('file-input').click()" id="select-btn" disabled>ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</button>
            </div>
            <p style="margin-top: 10px;">æ¥ç¶šå®Œäº†å¾Œã€é¸æŠã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¯è‡ªå‹•ã§é€ä¿¡ã•ã‚Œã¾ã™ã€‚</p>
            <h3>é€ä¿¡ã‚­ãƒ¥ãƒ¼</h3>
            <div id="send-queue-log">ï¼ˆå¾…æ©Ÿä¸­ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚ã‚Šã¾ã›ã‚“ï¼‰</div>
        </div>

        <div class="card">
            <h2>ğŸ“¥ ãƒ•ã‚¡ã‚¤ãƒ«å—ä¿¡ãƒ­ã‚°</h2>
            <div id="receive-log">æ¥ç¶šã‚’å¾…ã£ã¦ã„ã¾ã™...</div>
        </div>
        
        <div class="card">
            <h2>ğŸ› ãƒ‡ãƒãƒƒã‚°/ã‚¨ãƒ©ãƒ¼ãƒ­ã‚° <small>(æ¥ç¶šå•é¡Œã®ç¢ºèªã«åˆ©ç”¨)</small></h2>
            <div id="debug-log-card"></div>
        </div>
    </div>

    <script>
        // è¨­å®š
        const PEERJS_HOST = 'peerjs-server.com'; 
        const PEERJS_PORT = 443;
        const PEERJS_PATH = '/';
        const CHUNK_SIZE = 16 * 1024; // 16KB
        const HOST_PREFIX = 'p2p-host-';
        const MAX_RETRY = 10; // ã‚²ã‚¹ãƒˆå´ã®æœ€å¤§ãƒªãƒˆãƒ©ã‚¤å›æ•°
        const RETRY_INTERVAL = 3000; // 3ç§’

        // DOMè¦ç´ 
        const statusEl = document.getElementById('status');
        const pinEl = document.getElementById('shared-pin');
        const hostBtn = document.getElementById('host-btn');
        const guestBtn = document.getElementById('guest-btn');
        const dropAreaEl = document.getElementById('drop-area');
        const sendQueueLogEl = document.getElementById('send-queue-log');
        const receiveLogEl = document.getElementById('receive-log');
        const fileInputEl = document.getElementById('file-input');
        const selectBtn = document.getElementById('select-btn');
        const debugLogCardEl = document.getElementById('debug-log-card');
        const connectionCardEl = document.getElementById('connection-card');

        // çŠ¶æ…‹å¤‰æ•°
        let peer = null;
        let connection = null;
        let fileQueue = [];
        let isSending = false;
        let isHostMode = false;
        let retryCount = 0;

        // å—ä¿¡ãƒ‡ãƒ¼ã‚¿æ ¼ç´ç”¨
        let receivedFiles = {}; 
        
        // ----------------------------------------------------
        // I. ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
        // ----------------------------------------------------

        function logDebug(message, isError = false) {
            const entry = document.createElement('div');
            entry.className = 'debug-entry';
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${isError ? 'ERROR' : 'INFO'} | ${message}`;
            entry.style.color = isError ? 'var(--danger-color)' : 'var(--info-color)';
            debugLogCardEl.prepend(entry);
        }

        function getHostId(pin) {
            // PINã«ä¸é©åˆ‡ãªæ–‡å­—ãŒå«ã¾ã‚Œãªã„ã‹ç¢ºèª
            const safePin = pin.trim().replace(/[^a-zA-Z0-9_-]/g, '');
            return HOST_PREFIX + safePin;
        }

        function validatePin(pin) {
            if (!pin || pin.trim().length === 0) {
                alert('å…±æœ‰ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
                return false;
            }
            if (pin.trim().length > 15) {
                alert('å…±æœ‰ã‚³ãƒ¼ãƒ‰ã¯15æ–‡å­—ä»¥å†…ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚');
                return false;
            }
            return true;
        }

        // ----------------------------------------------------
        // II. æ¥ç¶šãƒ¢ãƒ¼ãƒ‰ã®é–‹å§‹ã¨åˆæœŸåŒ–
        // ----------------------------------------------------

        function resetState() {
            logDebug("Resetting application state.");
            if (peer) {
                peer.destroy(); 
                peer = null;
            }
            connection = null;
            isSending = false;
            isHostMode = false;
            retryCount = 0;
            pinEl.disabled = false;
            hostBtn.disabled = false;
            guestBtn.disabled = false;
            selectBtn.disabled = true;
            connectionCardEl.style.display = 'block'; 
            
            sendQueueLogEl.innerHTML = 'ï¼ˆå¾…æ©Ÿä¸­ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚ã‚Šã¾ã›ã‚“ï¼‰';
            if (!receiveLogEl.textContent.includes('æ¥ç¶šã‚’å¾…ã£ã¦ã„ã¾ã™...')) {
                receiveLogEl.innerHTML += '<p style="color: red;">æ¥ç¶šãŒåˆ‡æ–­ã•ã‚Œã¾ã—ãŸã€‚å†æ¥ç¶šã—ã¦ãã ã•ã„ã€‚</p>';
            }
        }

        function initializePeer(id = null) {
            logDebug(`Initializing PeerJS with ID: ${id || 'random'}`);
            if (peer) peer.destroy(); 

            updateStatus('æ¥ç¶šIDç”Ÿæˆä¸­...', 'status-connecting');
            
            // WebRTCã®æ¥ç¶šã‚’å®‰å®šã•ã›ã‚‹ãŸã‚ã®è¨­å®šï¼ˆICE/STUN/TURNï¼‰ã‚’è¿½åŠ 
            const peerConfig = {
                host: PEERJS_HOST,
                port: PEERJS_PORT,
                path: PEERJS_PATH,
                secure: true,
                config: {
                    'iceServers': [
                        // GoogleãŒæä¾›ã™ã‚‹å…¬å…±ã®STUNã‚µãƒ¼ãƒãƒ¼ã‚’è¿½åŠ  (æ¥ç¶šç¢ºç«‹ã‚’é«˜é€ŸåŒ–)
                        { 'urls': 'stun:stun.l.google.com:19302' },
                        { 'urls': 'stun:stun1.l.google.com:19302' },
                    ]
                }
            };
            
            peer = new Peer(id, peerConfig);

            peer.on('open', (peerId) => {
                logDebug(`Peer ready. ID: ${peerId}`);
                updateStatus(isHostMode ? `ãƒ›ã‚¹ãƒˆå¾…æ©Ÿä¸­ (${peerId})` : 'ã‚²ã‚¹ãƒˆæ¥ç¶šæº–å‚™å®Œäº†', 'status-ready');
                
                if (!isHostMode) {
                    retryConnectToHost();
                } else {
                    peer.on('connection', (conn) => {
                        if (connection && connection.open) {
                            logDebug("Incoming connection rejected: Already connected.", true);
                            conn.close();
                            return;
                        }
                        logDebug("Incoming connection received (Host side).");
                        handleConnection(conn, true);
                        receiveLogEl.innerHTML = 'ç›¸æ‰‹ï¼ˆã‚²ã‚¹ãƒˆï¼‰ã‹ã‚‰ã®æ¥ç¶šã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸã€‚';
                    });
                }
            });

            peer.on('error', (err) => {
                logDebug(`Peer Error: ${err.type} | ${err.message}`, true);
                if (err.type !== 'peer-unavailable') { // peer-unavailableã¯ã‚²ã‚¹ãƒˆå´ãƒªãƒˆãƒ©ã‚¤ãƒ­ã‚¸ãƒƒã‚¯ã§å‡¦ç†
                    updateStatus('æ¥ç¶šã‚¨ãƒ©ãƒ¼', 'status-error');
                    resetState();
                }
            });

            peer.on('close', () => {
                logDebug("Peer closed.", true);
                updateStatus('åˆ‡æ–­ã•ã‚Œã¾ã—ãŸ', 'status-disconnected');
                resetState();
            });
        }
        
        function startHost() {
            const pin = pinEl.value.trim();
            if (!validatePin(pin)) return;
            isHostMode = true;
            pinEl.disabled = true;
            hostBtn.disabled = true;
            guestBtn.disabled = true;
            initializePeer(getHostId(pin));
        }

        function startGuest() {
            const pin = pinEl.value.trim();
            if (!validatePin(pin)) return;
            isHostMode = false;
            pinEl.disabled = true;
            hostBtn.disabled = true;
            guestBtn.disabled = true;
            initializePeer(); 
        }

        // ----------------------------------------------------
        // III. ã‚²ã‚¹ãƒˆæ¥ç¶šãƒªãƒˆãƒ©ã‚¤ãƒ­ã‚¸ãƒƒã‚¯
        // ----------------------------------------------------

        function retryConnectToHost() {
            const targetId = getHostId(pinEl.value);
            
            if (retryCount >= MAX_RETRY) {
                logDebug(`Guest failed to connect after ${MAX_RETRY} retries. Target ID: ${targetId}`, true);
                updateStatus('æ¥ç¶šå¤±æ•—', 'status-error');
                resetState();
                return;
            }

            logDebug(`Guest attempting connection to ${targetId} (Attempt ${retryCount + 1}/${MAX_RETRY}).`);
            updateStatus(`ãƒ›ã‚¹ãƒˆã«æ¥ç¶šä¸­... (ãƒªãƒˆãƒ©ã‚¤ ${retryCount + 1})`, 'status-connecting');

            const conn = peer.connect(targetId, { reliable: true }); 

            let finished = false; 

            conn.on('open', () => {
                if (finished) return; 
                finished = true;
                logDebug("Connection successful (Guest side).");
                handleConnection(conn, false);
            });

            conn.on('error', (err) => {
                logDebug(`Connection Error during attempt: ${err.message}`, true);
                if (!finished && err.type === 'peer-unavailable') {
                    retryCount++;
                    setTimeout(retryConnectToHost, RETRY_INTERVAL);
                } else if (!finished) {
                    finished = true;
                    updateStatus('æ¥ç¶šã‚¨ãƒ©ãƒ¼', 'status-error');
                    resetState();
                }
            });
            
            conn.on('close', () => {
                logDebug("Connection closed during attempt or after establishment.", true);
                if (!finished) {
                     if (retryCount < MAX_RETRY) {
                         retryCount++;
                         setTimeout(retryConnectToHost, RETRY_INTERVAL);
                     } else {
                         finished = true;
                         updateStatus('æ¥ç¶šå¤±æ•—', 'status-error');
                         resetState();
                     }
                }
            });
        }

        // ----------------------------------------------------
        // IV. æ¥ç¶šç¢ºç«‹å¾Œã®å…±é€šãƒãƒ³ãƒ‰ãƒ©
        // ----------------------------------------------------

        function handleConnection(conn, isReceiver) {
            connection = conn;
            retryCount = 0; 
            selectBtn.disabled = false; 
            connectionCardEl.style.display = 'none'; // PINå…¥åŠ›ã‚¨ãƒªã‚¢ã‚’éš ã™

            conn.on('open', () => {
                updateStatus('æ¥ç¶šå®Œäº†ï¼ P2Pé€šä¿¡é–‹å§‹', 'status-success');
                if (!isReceiver) {
                    processQueue(); 
                }
            });

            conn.on('data', (data) => {
                if (data.type === 'metadata') {
                    handleMetadata(data);
                } else if (data.type === 'file-chunk') {
                    handleChunk(data);
                }
            });

            conn.on('close', () => {
                logDebug("Connection permanently closed.", true);
                updateStatus('åˆ‡æ–­ã•ã‚Œã¾ã—ãŸ', 'status-disconnected');
                resetState();
            });
        }

        function updateStatus(text, className) {
            statusEl.textContent = text;
            statusEl.className = className;
        }
        
        // ----------------------------------------------------
        // V. é€ä¿¡å‡¦ç† (ã‚­ãƒ¥ãƒ¼ç®¡ç†, ãƒãƒ£ãƒ³ã‚¯åŒ–)
        // ----------------------------------------------------

        // ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã‚¤ãƒ™ãƒ³ãƒˆ
        fileInputEl.addEventListener('change', (e) => {
            addFilesToQueue(Array.from(e.target.files));
            e.target.value = ''; 
        });

        // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚¤ãƒ™ãƒ³ãƒˆ
        dropAreaEl.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropAreaEl.classList.add('drag-over');
        });
        dropAreaEl.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropAreaEl.classList.remove('drag-over');
        });
        dropAreaEl.addEventListener('drop', (e) => {
            e.preventDefault();
            dropAreaEl.classList.remove('drag-over');
            const files = Array.from(e.dataTransfer.files);
            addFilesToQueue(files);
        });

        function addFilesToQueue(files) {
            if (!connection || !connection.open) {
                alert('ãƒ•ã‚¡ã‚¤ãƒ«é€ä¿¡ã«ã¯ã€ã¾ãšç›¸æ‰‹ã¨æ¥ç¶šã‚’ç¢ºç«‹ã—ã¦ãã ã•ã„ã€‚');
                return;
            }
            files.forEach(file => {
                const fileId = Date.now() + Math.random(); 
                fileQueue.push({ id: fileId, file: file, status: 'Queued' });
            });
            renderSendQueue();
            if (connection && connection.open && !isSending) {
                processQueue();
            }
        }

        function renderSendQueue() {
            if (fileQueue.length === 0) {
                sendQueueLogEl.innerHTML = 'ï¼ˆå¾…æ©Ÿä¸­ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚ã‚Šã¾ã›ã‚“ï¼‰';
                return;
            }
            sendQueueLogEl.innerHTML = fileQueue.map(item => {
                const sizeMB = (item.file.size / 1024 / 1024).toFixed(2);
                let html = `<div class="log-item" id="send-log-${item.id}">`;
                html += `<span style="font-weight: bold;">[${item.status}] ${item.file.name}</span> (${sizeMB} MB)`;
                
                if (item.status === 'Sending') {
                    html += `<div class="progress-bar-container">
                                <div class="progress-bar" id="send-progress-${item.id}" style="width: 0%">0%</div>
                             </div>`;
                }
                html += `</div>`;
                return html;
            }).join('');
        }

        async function processQueue() {
            if (isSending || fileQueue.length === 0 || !connection || !connection.open) {
                return;
            }

            isSending = true;
            const item = fileQueue[0]; 
            item.status = 'Sending';
            renderSendQueue();

            const file = item.file;
            const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
            let offset = 0;
            const sendProgressEl = document.getElementById(`send-progress-${item.id}`);

            logDebug(`Starting transfer of ${file.name}. Total chunks: ${totalChunks}`);
            
            // 1. ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡
            connection.send({
                type: 'metadata',
                fileId: item.id,
                name: file.name,
                size: file.size,
                totalChunks: totalChunks
            });

            // 2. ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åˆ†å‰²ã—ã¦é€ä¿¡
            try {
                while (offset < file.size) {
                    const slice = file.slice(offset, offset + CHUNK_SIZE);
                    const chunkData = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (event) => resolve(event.target.result);
                        reader.onerror = (error) => {
                            logDebug(`FileReader error for ${file.name}: ${error}`, true);
                            reject(error);
                        };
                        reader.readAsArrayBuffer(slice);
                    });

                    connection.send({
                        type: 'file-chunk',
                        fileId: item.id,
                        chunk: chunkData,
                        offset: offset
                    });

                    offset += CHUNK_SIZE;

                    // é€²æ—è¡¨ç¤ºã‚’æ›´æ–°
                    const progress = Math.min(100, (offset / file.size) * 100);
                    if (sendProgressEl) {
                        sendProgressEl.style.width = `${progress}%`;
                        sendProgressEl.textContent = `${progress.toFixed(1)}%`;
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 5)); 
                }

                // é€ä¿¡å®Œäº†
                item.status = 'å®Œäº†';
                fileQueue.shift(); 
                renderSendQueue();
                isSending = false;
                logDebug(`Transfer of ${file.name} completed.`);
                
                processQueue();

            } catch (e) {
                logDebug(`File sending failed: ${e.message}`, true);
                item.status = 'å¤±æ•—';
                fileQueue.shift();
                renderSendQueue();
                isSending = false;
                processQueue();
            }
        }

        // ----------------------------------------------------
        // VI. å—ä¿¡å‡¦ç† (ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿/ãƒãƒ£ãƒ³ã‚¯ã®çµåˆ)
        // ----------------------------------------------------

        function handleMetadata(data) {
            if (data.fileId && data.name && data.size) {
                logDebug(`Metadata received for file ID: ${data.fileId}, Name: ${data.name}`);

                if (receiveLogEl.textContent.includes('æ¥ç¶šã‚’å¾…ã£ã¦ã„ã¾ã™...')) {
                     receiveLogEl.innerHTML = ''; 
                }
                
                // æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«è»¢é€é–‹å§‹
                receivedFiles[data.fileId] = {
                    metadata: data,
                    chunks: [],
                    receivedBytes: 0,
                    logElement: createReceiveLogElement(data)
                };
            }
        }

        function createReceiveLogElement(data) {
            const sizeMB = (data.size / 1024 / 1024).toFixed(2);
            const div = document.createElement('div');
            div.className = 'log-item';
            div.id = `receive-log-${data.fileId}`;
            div.innerHTML = `
                <span>å—ä¿¡ä¸­: <strong>${data.name}</strong> (${sizeMB} MB)</span>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="receive-progress-${data.fileId}" style="width: 0%">0%</div>
                </div>`;
            receiveLogEl.prepend(div);
            return div;
        }

        function handleChunk(data) {
            const fileItem = receivedFiles[data.fileId];
            if (!fileItem) {
                logDebug(`Received chunk for unknown file ID: ${data.fileId}`, true);
                return;
            }

            fileItem.chunks.push(data.chunk);
            fileItem.receivedBytes += data.chunk.byteLength;

            const progress = Math.min(100, (fileItem.receivedBytes / fileItem.metadata.size) * 100);
            const progressBar = document.getElementById(`receive-progress-${data.fileId}`);
            if (progressBar) {
                progressBar.style.width = `${progress}%`;
                progressBar.textContent = `${progress.toFixed(1)}%`;
            }

            // å…¨ã¦ã®ãƒãƒ£ãƒ³ã‚¯ã‚’å—ä¿¡å®Œäº†ã—ãŸã‹ãƒã‚§ãƒƒã‚¯
            if (fileItem.receivedBytes >= fileItem.metadata.size) {
                logDebug(`File ID ${data.fileId} received completely. Starting Blob construction.`);
                
                // ArrayBufferã®é…åˆ—ã‚’ä¸€ã¤ã®Blobã«çµåˆ
                const receivedFile = new Blob(fileItem.chunks);
                
                // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯ã®ç”Ÿæˆ
                const downloadUrl = URL.createObjectURL(receivedFile);
                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = fileItem.metadata.name;
                a.className = 'download-link';
                a.textContent = `â¬‡ï¸ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†: ${fileItem.metadata.name} (ã‚¯ãƒªãƒƒã‚¯ã—ã¦ä¿å­˜)`;
                
                // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹å¾Œã«URLã‚’è§£æ”¾
                a.addEventListener('click', () => {
                    logDebug(`Download link clicked for ${fileItem.metadata.name}. Revoking URL in 500ms.`);
                    setTimeout(() => {
                        URL.revokeObjectURL(downloadUrl);
                    }, 500); 
                }, { once: true });

                // ãƒ­ã‚°è¡¨ç¤ºã®æ›´æ–°
                const logEl = fileItem.logElement;
                if (logEl) {
                    const progressContainer = logEl.querySelector('.progress-bar-container');
                    if(progressContainer) progressContainer.remove();
                    logEl.appendChild(a);
                    logEl.querySelector('span').textContent = 'å—ä¿¡å®Œäº†';
                }

                // ãƒ‡ãƒ¼ã‚¿è§£æ”¾
                delete receivedFiles[data.fileId];
            }
        }
    </script>
</body>
</html>
